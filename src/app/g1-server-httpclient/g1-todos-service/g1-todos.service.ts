// Сервис с основной логикой запросов на сервер

import { HttpClient, HttpEvent, HttpEventType, HttpHeaders, HttpParams } from "@angular/common/http"   
import { Injectable } from "@angular/core"
import { catchError, delay, Observable, tap, throwError } from "rxjs"

export interface Todo {         // Для удобства визуализации создадим интерфейс с нужными параметрами api ответа 
    completed: boolean
    title: string
    id?: number
  }
  
@Injectable({providedIn: 'root'})
export class TodosService {
    constructor (protected http: HttpClient) {} // Инжектируем защищенную переменную http типа HttpClient, тк у ее типа есть методы для работы с rest api


    // Далее в середине каждого метода ---отдельно--- будут дополнительно подробно рассмотрены опции типа возврата стрима


    addTodo(todo: Todo): Observable<Todo> {                                                // Принимаем переменную todo из компонента
        return this.http.post<Todo>('https://jsonplaceholder.typicode.com/todos', todo,    // Используем метод http post() и создаем на сервере новый объект, указываем post() тип данных <Todo>

        {headers: new HttpHeaders({'MyCustomHeader': Math.random().toString()})})          // Добавляем свой хедер (подробнее на 5 строк ниже)

                                   // Аргументы post() - 1. Куда отправить запрос, 2. Какой объект с данными {} (http превратит его в строку) или переменную отправить
                                   // Одновременно с созданием нового объекта на серве, создается стрим, который мы отправим в компонент и там подпишемся
                                   // Тк метод addTodo() возвращает стрим, указываем тип Observable и тип объекта, который стримят <Todo>
    }

    // У методов post() и get() есть 2. доп. аргумент, чтобы добавить к запросу/ответу header 
    // Headers это доп. информация, посылаемая вместе с запросом/ответом, которую можно посмотреть в network в chrome dev tools





    fetchTodos(): Observable<Todo[]> {

// ---------------------------------------------------------------------------- отдельная часть (query parameters) -----------------------------------------------------------------------------------------------
        let params = new HttpParams()   // Чтобы вызвать несколько query parameters (описание под методом), создаем переменную через let переписываем в нее значения через метод .append()
        params = params.append('_limit', '4')       // Аргументы .append() 1. query parameter, 2. значение
        params = params.append('custom', 'anything')    // Также можно вручную прописать query parameter в ссылке
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

                                                                                          // Используем метод get, чтобы получить ответ api
    return this.http.get<Todo[]>('https://jsonplaceholder.typicode.com/todos?_limit=2',   // По умолчанию стримы в ts имеют тип object, нужно указать в методе get какой тип получать - .get<Todo[]>

// ---------------------------------------------------------------------------- отдельная часть (стрим вывод типа body, response) -----------------------------------------------------------------------------------------------    
    {
        params: params,           // ключ: значение(переменная с несколькими query parameters)  2.1 аргумент get - options
                                  // "_limit=2" - это query parameter. Всегда пишется после '?' Это параметр особого обращения к элементам сервера. 
                                  // Чтобы создать свой query parameter, нужно исп. 2.1 Доп аргумент get() params

        observe: 'body'    // 2.2 аргумент чтобы определить, какой тип данных нужно получить в ответе 
                           // по умлочанию есть 3 типа данных - 'body', 'events', 'response'. Можно выбрать 'response' и с помощью map(response => {return response.body}) вернуть и body и response
                           // 'body' это по умолчанию вывод массива объектов
                           // 'response' это расширенный объект на уровень выше, содержащий в себе массив 'body' и доп инфу вывода (headers, status, type и тп)
                           // 'events' позволяет получить доступ до всех асинхронных событий, которые происходят с этим запросом (пример на методе removeTodo)
    })
// ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------                                                 
        
        // Пока мы не подписались на стрим, можно трансформировать данные или использовать задержку с помощью pipe()
        .pipe(delay(1000),
        catchError(error => {           // У стримов существет метод пайпа catchError для вывода ошибок (обязательно выводятся с помощью throwError() (создает новый observable) )
            console.log('Error: ', error.message)
            return throwError(error)
        }))
    }








    removeTodos(id: number | undefined): Observable<void | HttpEvent<void>> {                 // 2 тип для данных настройки observe: 'events' (подробнее выше)
        return this.http.delete<void>(`https://jsonplaceholder.typicode.com/todos/${id}`, {   // Метод delete возвращает null object, класс можно не указывать, но для наглядности это <void>
                                                                                              // Аргументы delete() - 1. Куда отправить запрос. Пишется с обратными кавычками ``

// ---------------------------------------------------------------------------- отдельная часть (стрим вывод типа event) -----------------------------------------------------------------------------------------------                                                                                                  
            observe: 'events'
        }).pipe(
            tap(event =>{    // Для демонстрации вывода events вызовем оператор перехвата промежуточных данных tap() с помощью pipe() и получим 2 его разных состояния при удалении
                if (event.type === HttpEventType.Sent) {// В енуме (ts enum) HttpEventType лежат все состояния стрима. С их помощью можно вызывать тригеры, чтобы знать текущий статус стрима
                    console.log('Sent ', event)         // Sent - событие отправки запроса
                }
                if (event.type === HttpEventType.Response) {    // Response - событие ответа сервера
                    console.log('Response ', event)
                }
            })
        )
    }                                                                                       
// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------    





    completeTodo(id: number | undefined): Observable<Todo> {
        return this.http.put<Todo>(`https://jsonplaceholder.typicode.com/todos/${id}`, {completed: true}, {  // Обращаемся к серверу (http) и вызываем метод put с типом <Todo> для модификации эл-тов на сервере
                                                // Аргументы put(): 1. Куда отправить запрос. Пишется с обратными кавычками ``, 2. Поля, которые модифицируем в {}. 

// ---------------------------------------------------------------------------- отдельная часть (тип ответа с сервера) -----------------------------------------------------------------------------------------------                                                                                                  
        responseType: 'json'   //  Клиент  (логика на Ts, Js) перед тем, как отправить запрос на сервер, преобразует его (по умолчанию с помощью JSON.stringify(obj) в формате json)
        })                     //  А когда сервер отвечает, angular парсит json обратно и отдает нормальное значение. Если поставить 'text', angular не будет парсить и передаст строку
    }       //  Так что эта настройка нужна, если необходимо сделать доп. манипуляции на этапе парсинга. Чтобы парсить вручную, необходимо воспользоваться методом object = JSON.parse(object)
}
// ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------    